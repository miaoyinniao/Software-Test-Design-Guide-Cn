<html>
<head>
  <title>11.1 技术</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/268644 (zh-CN); Windows/5.1.2600 Service Pack 2;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2064"/>
<h1>11.1 技术</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><table border="0" cellpadding="0" cellspacing="0" style="font-size: 24px;" width="100%"><tbody><tr><td><div style="text-align: left;margin-left: 0.15in;">技术</div></td><td align="right"><br></td></tr></tbody></table><div><span style="font-size: 24px;"><a name="379"></a><a name="IDX-169"></a></span><div style="font-size: 24px;"><br></div><div style="font-size: 24px;">变量在赋予数据值时有一个生命周期，它们被创建，使用，销毁。在一些编程语言中（比如FORTRAN和BASIC）创建和销毁是自动的。一个变量在第一次创建后被赋予一个值，当程序结束时变量自动销毁。</div><p style="font-size: 24px;">在另外一些语言中（像C, C++, 和Java），创建是正式的，变量像这样声明：</p><div style="font-size: 24px;"><pre>
       int x;    // x is created as an integer
       string y; // y is created as a string
</pre></div><div style="font-size: 24px;"><br></div><div style="font-size: 24px;">这些声明生成在一个代码块中，代码块开始于{结束于}。变量定义在块中定义创建并执行，当块结束时自动销毁。这个叫做变量的范围。</div><div style="font-size: 24px;">比如：</div><div style="font-size: 24px;"><pre>
    {           // begin outer block
     int x;     // x is defined as an integer within this outer block
    ...;        // x can be accessed here
       {        // begin inner block
       int y;   // y is defined within this inner block
    ...;        // both x and y can be accessed here
       }        // y is automatically destroyed at the end of
                // this block
       ...;     // x can still be accessed, but y is gone
    }    // x is automatically destroyed
</pre></div><div style="font-size: 24px;"><br></div><div style="font-size: 24px;">变量能用于计算（a=b+1）。它们同样可以用于条件（a&gt;42），两种用法都需要在使用它们之前给他们赋值。</div><div style="font-size: 24px;"><br></div><div style="font-size: 24px;">变量在程序路径中第一次出现可能存在3种情况：</div><div style="font-size: 24px;"><table border="0" style="font-size: 24px;"><tbody><tr valign="top"><td align="left"><p>1.</p></td><td align="left"><p>~d</p></td><td align="left"><p>变量不存在(~表示d)，那么它被定义成d。</p></td></tr><tr valign="top"><td align="left"><p>2.</p></td><td align="left"><p>~u</p></td><td align="left"><p>变量不存在，它被使用。</p></td></tr><tr valign="top"><td align="left"><p>3.</p></td><td align="left"><p>~k</p></td><td align="left"><p>变量不存在，它被销毁。</p></td></tr></tbody></table></div><p style="font-size: 24px;">第一种情况是正确的，变量不存在那么定义它。第二种是不正确的，变量不存在不应该使用。第三种也许不正确，销毁一个没创建的变量是一个程序错误。</p><p style="font-size: 24px;">现在考虑下面的定义d，u，k的时间序列对：</p><div style="font-size: 24px;"><table border="0" style="font-size: 24px;"><tbody><tr valign="top"><td align="left"><p>dd</p></td><td align="left"><p>定义和再次定义-不是无效的但是疑似程序错误。</p></td></tr><tr valign="top"><td align="left"><p>du</p></td><td align="left"><p>定义和使用-也许完全正确，正常的用例。</p></td></tr><tr valign="top"><td align="left"><p>dk</p></td><td align="left"><p>定义后销毁-不是无效的但是疑似程序错误。</p></td></tr><tr valign="top"><td align="left"><p>ud</p></td><td align="left"><p>使用后定义—可接受。</p></td></tr><tr valign="top"><td align="left"><p>uu</p></td><td align="left"><p>使用后使用—可接受。</p></td></tr><tr valign="top"><td align="left"><p>uk</p></td><td align="left"><p>使用和销毁—可接受。</p></td></tr><tr valign="top"><td align="left"><p>kd</p></td><td align="left"><p>销毁和定义—可接受.，一个变量销毁后重新定义。</p></td></tr><tr valign="top"><td align="left"><p>ku</p></td><td align="left"><p>销毁后使用—严重缺陷.使用一个不存在的变量或者没定义的变量是错误的。</p></td></tr><tr valign="top"><td align="left"><p>kk</p></td><td align="left"><p>销毁后销毁—也许是个程序错误。</p></td></tr></tbody></table></div><table border="0" cellpadding="0" cellspacing="0" style="font-size: 24px;"><tbody><tr><td valign="top"></td><td valign="top" width="80">关键点</td><td valign="top"><p>参考定义，使用，销毁的时间序列对来检查变量。</p></td></tr></tbody></table><span style="font-size: 24px;"><a name="381"></a><a name="IDX-171"></a></span><div style="font-size: 24px;"><br></div><div style="font-size: 24px;">数据流图类似于控制流图，另外它详细描述每个模块变量的定义，使用，销毁。我们将构建这个图和验证define-use-kill模式是合适的。第一，我们展示图的静态测试。静态的意思是我们检测流图（通过审查或者人工查看）。第二，我们展示模块的动态测试，动态的意思是我们构建和执行测试用例。让我们开始静态测试。</div><div style="font-size: 24px;"><h3 style="font-size: 26px;"><span style="font-size: 24px;">静态数据流测试</span></h3><div>下面的控制流图标记了各个变量define-use-kill信息。</div><div><img src="11.1 技术_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div>Figure 11-1: The control flow diagram annotated with define-use-kill information for each of the module's variables.</div><a name="384"></a><a name="IDX-172"></a><p>对于每个变量我们沿着控制流图运用define-use-kill 模式检查，考虑X的左右路径：</p><div><img src="11.1 技术_files/data.JPG" type="image/jpeg" style="cursor: default;cursor: default;cursor: default;"/><a name="385"></a><br style="LINE-HEIGHT: 1">
Figure 11-2: The control flow diagram annotated with define-use-kill information for the x variable.</div><div><br></div><div>对X应用define-use-kill模式：</div><div><table border="0" style="font-size: 24px;"><tbody><tr valign="top"><td align="left"><p>~define</p></td><td align="left"><p>正确,正常情况</p></td></tr><tr valign="top"><td align="left"><p>define-define</p></td><td align="left"><p>疑似错误</p></td></tr><tr valign="top"><td align="left"><p>define-use</p></td><td align="left"><p>正确,正常情况</p></td></tr></tbody></table></div><a name="386"></a><a name="IDX-173"></a><p>现在看Y.注意第一个分支对Y没有影响。</p><div><a name="387"></a><img src="11.1 技术_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;"/><br style="LINE-HEIGHT: 1">
Figure 11-3: The control flow diagram annotated with define-use-kill information for the y variable.</div><p>对Y应用define-use-kill模式:</p><div><table border="0" style="font-size: 24px;"><tbody><tr valign="top"><td align="left"><p>~use</p></td><td align="left"><p>严重缺陷</p></td></tr><tr valign="top"><td align="left"><p>use-define</p></td><td align="left"><p> 可接受</p></td></tr><tr valign="top"><td align="left"><p>define-use</p></td><td align="left"><p> 正确,正常情况</p></td></tr><tr valign="top"><td align="left"><p>use-kill</p></td><td align="left"><div> 可接受</div></td></tr><tr valign="top"><td align="left"><p>define-kill</p></td><td align="left"><p>可能是个错误</p></td></tr></tbody></table></div><a name="388"></a><a name="IDX-174"></a><p>现在是Z</p><div><img src="11.1 技术_files/data——z.JPG" type="image/jpeg" style="cursor: default;cursor: default;"/><a name="389"></a><br style="LINE-HEIGHT: 1">
Figure 11-4: The control flow diagram annotated with define-use-kill information for the z variable.</div><div>对z应用define-use-kill模式:</div><div><table border="0" style="font-size: 24px;"><tbody><tr valign="top"><td align="left"><p>~kill</p></td><td align="left"><div>缺陷</div></td></tr><tr valign="top"><td align="left"><p>kill-use</p></td><td align="left"><div>严重缺陷</div></td></tr><tr valign="top"><td align="left"><p>use-use</p></td><td align="left"><div>正确,正常情况</div></td></tr><tr valign="top"><td align="left"><p>use-define</p></td><td align="left"><div>可接受</div></td></tr><tr valign="top"><td align="left"><p>kill-kill</p></td><td align="left"><p>也许是程序错误</p></td></tr><tr valign="top"><td align="left"><p>kill-define</p></td><td align="left"><div>可接受</div></td></tr><tr valign="top"><td align="left"><p>define-use</p></td><td align="left"><div>正确,正常情况</div></td></tr></tbody></table></div><a name="390"></a><a name="IDX-175"></a><p>通过静态分析，发现下面的错误：</p><div><pre>
       x: define-define
       y: ~use
       y: define-kill
       z: ~kill
       z: kill-use
       z: kill-kill
</pre></div><div><br></div><div>不幸的是，虽然静态测试能够检测到很多数据流错误，但它不能发现所有错误。考虑下面的情况：</div><div>1. 数组是数据元素的集合，它们公用名字和类型，比如</div><div><pre>
       int stuff[100];
</pre></div><p>定义了数组名stuff包含100个整型元素，在C, C++, 和Java中每个元素命名为stuff[0], stuff[1], stuff[2]等.数组作为一个单元被定义和销毁但是特定元素是单独使用的,程序员经常引用stuff[j] ，而j在程序执行时会动态变化。在一般情况下，静态分析不能确定define-use-kill规则是否跟踪准确除非每个元素单独考虑。</p>
2. 在复杂的控制流中，有一些特定路径永远也不会执行到，这种情况下一个不当的define-use-kill 组合也许存在，但是永远不会执行，所以它是不恰当的。</div><div><br><span style="font-size: 24px;">3. 在处理中断的系统中，一些</span><span style="font-size: 24px;">define-use-kill动作也许会在中断层面发生而其他</span><span style="font-size: 24px;">define-use-kill动作在main进程层次发生。另外，如果系统使用了多层次执行优先级，静态分析将会有无数种可能的交互，那么手工去分析将会非常困难。</span><p style="font-size: 24px;">因此，我们讨论动态数据流测试。</p></div><div style="font-size: 24px;"><h3 style="font-size: 26px;"><font size="3" style="font-size: 24px;"><a name="392"></a><a name="ch11lev2sec2"></a>动态数据流测试</font></h3><div>因为数据流基于控制流，它假设控制流基本正确。数据流测试过程是选择足够的测试用例比如：</div><ul><li><p>跟踪每个 &quot;define&quot; 的每个 &quot;uses&quot;</p></li><li><p>跟踪每个&quot;use&quot; 相对应的 &quot;define&quot;</p></li></ul><p>这样做的话，需要列举模块的路径。这个方法和控制流一样:开始于模块的入口点，取左分支到结束。回到开始验证第一个分支条件到结束，回到开始验证第二个分支条件到结束。接着第三直到所有分支已经列出，然后，对于所有变量，至少创建一个用例去覆盖每个define-use对。</p></div></div><table border="0" cellpadding="0" cellspacing="0" style="font-size: 24px;" width="100%"><tbody><tr><td><div style="MARGIN-LEFT: 0.15in"><br></div></td><td align="right"><div style="MARGIN-LEFT: 0.15in"><a href="mk://LiB0078.html"><img align="middle" alt="Previous Section" border="0" height="15" src="mk://images/previous.gif" style="cursor: default;cursor: default;cursor: default;cursor: default;" width="62"></img></a> <a href="mk://LiB0080.html"><img align="middle" alt="Next Section" border="0" height="15" src="mk://images/next.gif" style="cursor: default;cursor: default;cursor: default;cursor: default;" width="41"></img></a></div></td></tr></tbody></table></div>
</div></body></html> 